class Data {
  constructor(data) {
    this.categories = data.categories;
    this.labels = data.labels;
    this.nbColumns = data.nbColumns;
    this.nbLinesOriginal = data.nbLines;
    this.sampleIdList = data.sampleIdList;
    this.columns = data.columns.map(
      (column) =>
        new Column(
          this,
          column.index,
          column.label,
          column.values,
          column.category,
          column.type,
          column.group
        )
    );

    this.resetData();
  }

  resetData() {
    this.nbLines = this.nbLinesOriginal;
    this.selectedData = [...Array(this.nbLinesOriginal).keys()];
    this.verticallyUnfoldedColumnsIndexes = []; // Ordered list of unfolded columns
    this.virtualIndexMapping = {}; // Mapping between virtual index and original index

    // Remove any column that was generated by the unfolding
    this.columns = this.columns.filter((column) => column.unfoldedLevel === 0);
  }

  currentlyUnfoldedVertically() {
    // Return true if at least one column is unfolded
    return this.verticallyUnfoldedColumnsIndexes?.length > 0;
  }

  // Column unfold
  unfoldColumn(columnIndex) {
    if (this.columns[columnIndex].typeText === "Dict") this.unfoldHorizontally(columnIndex);
    else if (this.columns[columnIndex].typeText === "Array") this.unfoldVertically(columnIndex);
  }
  unfoldVertically(columnIndex) {
    // Add column to the unfolded list
    if (this.verticallyUnfoldedColumnsIndexes.includes(columnIndex)) {
      // Remove it from the unfolded list if it is already unfolded
      this.verticallyUnfoldedColumnsIndexes = this.verticallyUnfoldedColumnsIndexes.filter(
        (index) => index !== columnIndex
      );
    } else this.verticallyUnfoldedColumnsIndexes.push(columnIndex);

    // Set the unfolded column to unfolded
    this.columns.forEach(
      (column) => (column.unfolded = this.verticallyUnfoldedColumnsIndexes.includes(column.index))
    );

    // Update data based on vertical unfold
    if (!this.currentlyUnfoldedVertically()) {
      this.resetData();
      return;
    }

    // Compute the new number of lines and link the virtual index to the original index
    const unfoldedColumn = this.columns[this.verticallyUnfoldedColumnsIndexes[0]];
    const virtualIndexMapping = {};
    let nbLines = 0;
    for (let i = 0; i < this.nbLinesOriginal; i++) {
      const value = unfoldedColumn.originalValues[i];
      console.log(value);

      // Check if the value is an array
      if (!Array.isArray(value)) continue;

      // Register the virtual index mapping
      for (let j = 0; j < value.length; j++) {
        virtualIndexMapping[nbLines] = {
          originalIndex: i,
          valueIndex: j,
        };
        nbLines++;
      }
    }

    this.nbLines = nbLines;
    this.selectedData = [...Array(nbLines).keys()];
    this.virtualIndexMapping = virtualIndexMapping;

    console.log("Creating new column");

    // Add the column that is generated by the unfolding
    const column_values = new Array(nbLines).fill(null).map((_, i) => {
      const originalIndex = virtualIndexMapping[i].originalIndex;
      const valueIndex = virtualIndexMapping[i].valueIndex;
      return unfoldedColumn.originalValues[originalIndex][valueIndex];
    });
    const new_label = unfoldedColumn.label + " (unfolded)";

    this.columns.push(
      new Column(
        this,
        this.columns.length,
        new_label,
        column_values,
        unfoldedColumn.category,
        null,
        unfoldedColumn.label,
        1
      )
    );
  }
  unfoldHorizontally() {
    // TODO
  }
}

class Column {
  constructor(data, index, label, values, category, typeIn, group, unfoldedLevel = 0) {
    this.data = data;
    this.index = index;
    this.label = label;
    this.originalValues = values;
    this.category = category;
    this.group = group;
    this.unfoldedLevel = unfoldedLevel;
    this.unfolded = false;

    // this.min = column.min;
    // this.max = column.max;
    // this.nbOccurrence = column.nbOccurrence;
    // this.type = column.type;
    // this.typeText = column.typeText;
    // this.valuesIndex = column.valuesIndex;
    // this.valuesIndexUniques = column.valuesIndexUniques;
    // this.uniques = column.uniques;

    this.values = new Proxy(this.originalValues, {
      get: (target, prop) => {
        // Return the value based on the original index
        if (!this.data.currentlyUnfoldedVertically()) {
          if (prop === "length") return this.data.nbLines;
          if (prop === "map") return target.map;
          if (prop === "reduce") return target.reduce;
          console.log(prop, this.originalValues[prop]);
          return this.originalValues[prop];
        }

        // Return the value based on the virtual index
        if (prop === "length") return this.data.nbLines;
        else if (prop === "map")
          return (callback) => {
            return this.data.selectedData.map((virtualIndex) => {
              return callback(target[this.data.virtualIndexMapping[virtualIndex]].originalIndex);
            });
          };
        else if (prop === "reduce")
          return (callback, initialValue) => {
            return this.data.selectedData.reduce((acc, virtualIndex) => {
              return callback(
                acc,
                target[this.data.virtualIndexMapping[virtualIndex]].originalIndex
              );
            }, initialValue);
          };
        else if (prop === "_isVue") return true;
        else if (prop === "__ob__") return { dep: { id: 0 } };

        console.log(this.data.virtualIndexMapping);
        console.log(prop, target[this.data.virtualIndexMapping[prop].originalIndex]);

        return target[this.data.virtualIndexMapping[prop].originalIndex];
      },
    });

    this.defineColumnProperties(typeIn);
  }

  min(arr) {
    let min = Infinity;
    for (let i = 0; i < arr.length; i++) if (arr[i] < min) min = arr[i];
    return min;
  }
  max(arr) {
    let max = -Infinity;
    for (let i = 0; i < arr.length; i++) if (arr[i] > max) max = arr[i];
    return max;
  }

  defineColumnProperties(typeIn) {
    // Creating the column object

    this.uniques = [...new Set(this.originalValues)];
    this.nbOccurrence = this.uniques.length;

    // Checking if the this.umn is type text, number or got undefined values
    if (this.uniques.findIndex((v) => v === undefined || v === "" || v === null) >= 0) {
      // undefined Values
      this.type = undefined;
      this.typeText = "undefined";
      this.undefinedIndexes = this.originalValues
        .map((v, i) => (v == undefined || v == "" || v == null ? i : -1))
        .filter((v) => v >= 0);
      console.warn("Undefined values : " + this.label);
      console.warn(this.uniques);
      console.warn(this.originalValues);
    } else if (!(this.uniques.findIndex((v) => !Array.isArray(v)) >= 0)) {
      // If all the values are arrays
      this.type = Array;
      this.typeText = "Array";
    } else if (this.uniques.findIndex((v) => typeof v !== "object")) {
      // If all the values are dictionaries
      this.type = Object;
      this.typeText = "Dict";
    } else if (typeIn === "text" || this.uniques.find((v) => isNaN(v))) {
      // String Values
      this.type = String;
      this.typeText = "Class";
      let tmpUniqMap = {};
      this.valuesIndexUniques = this.uniques.map((str, i) => {
        tmpUniqMap[str] = i;
        return i;
      });

      this.valuesIndex = this.values.map((str) => tmpUniqMap[str]);
      this.min = this.min(this.valuesIndexUniques);
      this.max = this.max(this.valuesIndexUniques);
    } else {
      // Default Type
      this.type = Number;
      this.typeText = "Num";
      this.originalValues = this.originalValues.map((v) => +v);
      this.uniques = this.uniques.map((v) => +v);
      this.nbOccurrence = this.uniques.length;
      this.min = this.min(this.uniques);
      this.max = this.max(this.uniques);
      this.average = this.originalValues.reduce((a, b) => a + b, 0) / this.values.length || 0;
      if (this.uniques.length < 100) this.uniques.sort((a, b) => a - b);
    }
  }
}

export default {
  Data,
  Column,
};
